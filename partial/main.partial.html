<div class="row visible-sm visible-xs">
    <div class="col-xs-6" style="padding: 10px 0 0 10px;">
        <ul class="nav nav-tabs nav-stacked" style="border: 0;" data-ng-repeat="link in links">
            <li><a data-ng-href="{{link.target}}" data-du-smooth-scroll="" data-offset="40">{{link.name}}</a></li>
        </ul>
    </div>
    <div style="right:0; padding-top: 10px;" class="col-xs-5">
        <img src="images/logo-bg.png" style="width:100%;" alt="Byte Buddy logo"/>
    </div>
    <div class="clearfix"></div>
</div>
<div class="row" id="welcome">
    <div class="col-md-7 col-md-offset-3">
        <div class="row">
            <div class="col-md-8 col-xs-12">
                <h2>Welcome, <br/>I'm your Byte Buddy!</h2>

                <p class="lead">
                    Byte Buddy is a code generation library for creating Java classes during the runtime of a Java
                    application and without the help of a compiler. Other than the code generation utilities that
                    <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Proxy.html">ship
                        with the Java Class Library</a>, Byte Buddy allows the creation of arbitrary classes and is not
                    limited to implementing interfaces for the creation of runtime proxies.
                </p>
            </div>
            <div class="col-md-4 hidden-sm hidden-xs">
                <img width="393" alt="Byte Buddy logo" src="images/logo-bg.png"/>
            </div>
        </div>
        <p>
            In order to use Byte Buddy, one does not require an understanding of Java byte code or the
            <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">class file format</a>.
            In contrast, Byte Buddy's API aims for code that is concise and easy to understand for
            everybody. Nevertheless, Byte Buddy remains fully customizable down to the possibility of defining custom
            byte code. Furthermore, the API was designed to be as non-intrusive as possible and as a result, Byte
            Buddy does not leave any trace in the classes that were created by it. For this reason, the generated
            classes can exist without requiring Byte Buddy on the class path. Because of this feature, Byte Buddy's
            mascot was chosen to be a ghost.
        </p>

        <p>
            Byte Buddy is written in Java 6 but supports the generation of classes for any Java version. Byte Buddy is a
            light-weight library and only depends on the visitor API of the Java byte code parser library
            <a href="http://asm.ow2.org/">ASM</a> which does itself
            <a href="http://search.maven.org/remotecontent?filepath=org/ow2/asm/asm/4.2/asm-4.2.pom">not require any
                further dependencies</a>.
        </p>

        <p>
            At first sight, runtime code generation can appear to be some sort of black magic that should be avoided and
            only few developers write applications that explicitly generate code during their runtime. However, this
            picture changes when creating libraries that need to interact with arbitrary code and unknown type
            hierarchies. In this context, a library implementer must often choose between either requiring a user to
            implement library-proprietary interfaces or to generate code at runtime when the user's type hierarchy
            becomes first known to the library. Many known libraries such as for example <i>Spring</i> or
            <i>Hibernate</i> choose the latter approach which is popular among their users under the term of using
            <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object"><i>Plain Old Java Objects</i></a>. As a result,
            code generation has become an ubiquitous concept in the Java space. Byte Buddy is an attempt to innovate
            the runtime creation of Java types in order to provide a better tool set to those relying on such
            functionality.
        </p>
    </div>
</div>
<div class="row" id="helloworld">
    <div class="col-md-3 hidden-sm hidden-xs" style="padding-right: 0;">
        <img alt="buddy-code" src="images/buddy-code.png"
             style="margin-top: 200px; float: right; width: 100%;">
    </div>
    <div class="col-md-7">
        <div class="row">
            <div class="col-xs-8 col-md-12">
                <h2>Hello world!</h2>
            </div>
            <div class="visible-sm visible-xs col-xs-5"
                 style="position:absolute; right: 0; margin-right: -15px; margin-top: -20px; z-index: -10;">
                <img alt="buddy-code" src="images/buddy-code.png" style="width: 100%;"/>
            </div>
            <div class="clearfix visible-sm visible-xs"></div>
        </div>
        <p>
            Saying <code>Hello World</code> with Byte Buddy is as easy as it can get. Any creation of a Java class
            starts with an instance of the <code>ByteBuddy</code> class which represents a configuration for creating
            new types:
        </p>

<pre class="prettyprint">
Class&lt;?&gt; dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .method(ElementMatchers.named("toString")).intercept(FixedValue.value("Hello World!"))
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded();

assertThat(dynamicType.newInstance().toString(), is("Hello World!"));
</pre>

        <p>
            The default <code>ByteBuddy</code> configuration which is used in the above example creates a Java
            class in the newest version of the class file format that is understood by the processing Java
            virtual machine. As hopefully obvious from the example code, the created type will extend the 
            <code>Object</code> class and overrides its <code>toString</code> method which should return a 
            fixed value of <code>Hello World!</code>. The method to be overridden is identified by a so-called 
            <code>ElementMatcher</code>. In the above example, a predefined element matcher
            <code>named(String)</code> is used which identifies methods by their exact names. Byte Buddy comes 
            with numerous predefined and well-tested matchers which are collected in the 
            <code>ElementMatchers</code> class and which can be easily composed. The creation of custom matchers 
            is however as simple as implementing the
            (<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">functional</a>)
            <code>ElementMatcher</code> interface.
        </p>

        <p>
            For implementing the <code>toString</code> method, the <code>FixedValue</code> class defines a constant
            return value for the overridden method. Defining a constant value is only one example of many method
            interceptors that ship with Byte Buddy. By implementing the <code>Implementation</code> interface, a
            method could however even be defined by custom byte code.
        </p>

        <p>
            Finally, the described Java class is created and then loaded into the Java virtual machine. For this
            purpose, a target class loader is required as well as a class loading strategy where we choose a wrapper
            strategy. The latter creates a new child class loader which wraps the given class loader and only knows
            about the newly created dynamic type. Eventually, we can convince ourselves of the result by calling the
            <code>toString</code> method on an instance of the created class and finding the return value to represent
            the constant value we expected.
        </p>
    </div>
</div>
<div class="row" id="getbytebuddy">
    <div class="col-md-7 col-md-offset-3">
        <h2>Getting Byte Buddy</h2>
        <dl>
            <dt>Download</dt>
            <dd>
                Byte Buddy is currently released in version {{version}}. You can download Byte Buddy directly
                from <a href="https://bintray.com/raphw/maven/ByteBuddy">its Bintray page</a>.
                <a href="https://bintray.com/raphw/maven/ByteBuddy/_latestVersion" class="social-link">
                    <img src="https://api.bintray.com/packages/raphw/maven/ByteBuddy/images/download.png"
                         alt="download latest version">
                </a>
                Alternatively, you can also download the
                <a href="https://github.com/raphw/byte-buddy/releases">source code from GitHub</a>.
            </dd>
        </dl>
        <dl>
            <dt>Repositories</dt>
            <dd>
                Byte Buddy releases are available from the <a href="http://search.maven.org/">Maven Central</a> and
                <a href="https://bintray.com/bintray/jcenter">JCenter</a> repositories. Using a build manager, it is
                therefore easy to define a project dependency on Byte Buddy. Before releasing your project, please take
                the time to read through the information on
                <a href="#dependency" data-du-smooth-scroll="" data-offset="40">maintaining a project dependency</a> on
                Byte Buddy.<br style="margin-bottom: 20px;"/>
                <tabset class="repository">
                    <tab ng-repeat="tab in tabs" heading="{{tab.title}}" active="tab.active">
                        <pre class="prettyprint" data-ng-bind="tab.content"></pre>
                    </tab>
                </tabset>
            </dd>
        </dl>
        <dl>
            <dt>Licence</dt>
            <dd>
                Byte Buddy is an open source project distributed under the liberal and business-friendly
                <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0 licence</a>. Its source code is
                <a href="https://github.com/raphw/byte-buddy">freely available on GitHub</a>. Please note that Byte
                Buddy depends on <a href="http://asm.ow2.org/license.html">the ASM library which is distributed under
                a BSD license</a>.
            </dd>
        </dl>
        <dl>
            <dt>Documentation</dt>
            <dd>
                There exists an extensive documentation of all of Byte Buddy's features on <a href="#/tutorial">the 
                tutorial page</a>. Furthermore, Byte Buddy's in-code documentation is available from its source code
                repositories <a href="/javadoc/{{version}}/index.html">and on this website</a>. A list of blog articles and 
                conference presentations on Byte Buddy is available 
                <a href="https://github.com/raphw/byte-buddy/wiki/Web-resources">on the project's wiki</a>.
            </dd>
        </dl>
    </div>
    <div class="col-md-2 visible-md visible-lg" style="margin-top:-30px;">
        <img alt="Byte Buddy logo" src="images/buddy-download.png" style="width:100%;">
    </div>
</div>

<div class="row" id="dependency">
    <div class="col-md-7 col-md-offset-3">
        <h2>Dependency maintenance</h2>

        <p>
            Byte Buddy is written on top of <a href="http://asm.ow2.org/">ASM</a>, a mature and well-tested
            library for reading and writing compiled Java classes. In order to allow for advanced type
            manipulations, Byte Buddy is intentionally exposing the ASM API to its users. Of course, the direct
            use of ASM remains fully optional and most users will most likely never require it. This choice was
            made such that a user of Byte Buddy is not restrained to its higher-level functionality but can
            implement custom implementations without a fuzz when it is necessary.
        </p>

        <p>
            However, this imposes one possible problem when relying onto Byte Buddy as a project dependency and
            making use of the exposed ASM API. The authors of ASM require their users to
            <a href="http://asm.ow2.org/doc/faq.html#Q15">repackage the ASM dependency into a different name
                space</a>. This is necessary because one cannot anticipate changes in the Java class file
            format what can lead to API incompatibilities of future versions of ASM. Because of this, each
            version of Byte Buddy is distributed in two different packaging formats:
        </p>
        <ul class="colored-list padded">
            <li><span>
                A no-dependency version that repackages the ASM dependency from its
                <code>org.objectweb.asm</code> into Byte Buddy's own namespace
                <code>net.bytebuddy.jar.asm</code>.
                Doing so, the ASM dependency is also contained within Byte Buddy's <i>jar</i> file. By using
                this version, you do not need to worry about possible ASM version clashes which might be caused
                by the use of ASM by both Byte Buddy and other libraries. If you do not plan to use ASM, do not
                know what ASM is or what this is all about, this is the version you want to use. The artifact ID
                of this packaging format is <code>byte-buddy</code>.
            </span></li>
            <li><span>
                A version with an explicit dependency on ASM in its original <code>org.objectweb.asm</code>
                namespace. This version <b>must only be used for repackaging</b> Byte Buddy and its ASM
                dependency into <b>your own</b> namespace. Never distribute your application while directly
                relying on this dependency. Otherwise, your users might experience version conflicts of
                different ASM versions on their class path. The artifact ID of this packaging format is
                <code>byte-buddy-dep</code>.
            </span></li>
        </ul>
        <p>
            Normally, you would use the first, no-dependency version. However, if you are using Byte Buddy and
            making use of the exposed ASM API, you <b>must</b> use the second version of Byte Buddy
            <b>and repackage it</b> into your own name space as suggested. This is in particularly true when
            you plan to redistribute your code for the use by others. Future versions of Byte Buddy will update
            their ASM dependency to newer version what will then lead to version clashes between different
            ASM versions that were repackaged by Byte Buddy, if you have not follow this recommendation!
            In contrast, the Byte Buddy API itself will only apply version compatible changes.
        </p>

        <p>
            There exist several tools that allow for an easy automatization of the repacking of dependencies
            during your build processes. You can for example use the
            <a href="http://maven.apache.org/plugins/maven-shade-plugin/examples/class-relocation.html">Shade
                plugin</a> for Maven. With Gradle, a similar tool is the <a
                href="https://github.com/johnrengelman/shadow">Shadow plugin</a>. Another alternative is
            <a href="http://code.google.com/p/jarjar/">jarjar</a>, a library that offers integration as an Ant task.
        </p>
    </div>
</div>
