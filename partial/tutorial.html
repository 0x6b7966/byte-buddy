<div class="row">
<div class="col-md-3 visible-md visible-lg" style="height: 100%;">
    <div class="sidebar hidden-print affix-top" role="complementary" data-affix="0">
        <div style="padding: 40px 0 0 15px;">
            <ul class="nav nav-tabs nav-stacked" style="border: 0;" data-ng-repeat="link in links">
                <li>
                    <a data-ng-href="{{link.target}}" data-du-smooth-scroll="" data-du-scrollspy="" data-offset="40">
                        {{link.name}}
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>
<div class="visible-xs visible-sm">
    <div class="hidden-print" role="complementary">
        <ul class="nav nav-tabs nav-stacked" style="border: 0;" data-ng-repeat="link in links">
            <li>
                <a data-ng-href="{{link.target}}" data-du-smooth-scroll="" data-du-scrollspy="" data-offset="40">
                    {{link.name}}
                </a>
            </li>
        </ul>
    </div>
</div>
<div class="col-md-8 col-md-offset-1" id="affixComponent">
<div class="row" style="background-color: orange; font-weight: bold; color: #ffffff; padding: 5px;">
    This tutorial is currently in the make. We hope to publish a first release of Byte
    Buddy together with the completed version of this tutorial and web page before July 2014!
</div>
<div class="row" id="concept">

<h2>Why runtime code generation?</h2>

<p>
    The Java language comes with a comparatively strict type system. Java requires all variables and objects
    to be of a specific type and an attempt to assign incompatible types will always cause an error. These
    errors are usually emitted by the Java compiler or at the very least by the Java runtime, if a
    developer has made erroneous use of explicit type castings. This behavior is great for writing business
    applications because business domains can usually be described in such an explicit manner. This way, we can
    use Java to build very readable and robust applications. Among other things, it is Java's type system
    that is responsible for Java's popularity in enterprise programming.
</p>

<p>
    However, by enforcing its strict type system, Java imposes limitations that restrict the language's
    scope of use in other domains. For example, when writing a library that is to be used by other Java
    applications, we are normally not able to use any type that is defined in the user's application
    because these types are unknown to us when our library is compiled. In order to call methods or access
    fields of the user's code, the Java Class Library comes with a reflection API. Using the reflection API,
    we are able to introspect unknown types and to call methods or access fields. Unfortunately, the use of
    the reflection API has two significant downsides:
</p>
<ul class="colored-list padded">
    <li><span>
        Using the reflection API is
        <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">slower</a> than a hard-coded method
        invocation: First, one needs to perform a rather expensive method lookup to get hold of an object that
        describes a specific method. And when a method is invoked, this requires the JVM to run native code
        which requires long run time compared to a direct invocation. However, modern JVMs know a concept called
        <a href="https://blogs.oracle.com/buck/entry/inflation_system_properties">inflation</a> where the
        JNI-based method invocation is replaced by generated byte code that is injected into a dynamically
        created class. As you can see, even the JVM itself uses code generation!
    </span></li>
    <li><span>
        The reflection API breaks type-safety: Even though the JVM is capable of improving the reflective
        runtime, we might be required to expose this reflective API to our library's users when enhancing
        the user types. However, type-safety is one of Java's strong suites. We do not want to take it away when
        interacting with out user's code. To get a better understanding of the problem, let us look at the
        example of a miniature security library.
    </span></li>
</ul>
<h4>Writing a security library</h4>

<p>
    Business applications can grow large and sometimes it is difficult to keep an overview of call stacks
    in our application. This can become problematic when we have crucial methods in our application that should
    only be called in special circumstances. Imagine a business application that implements a reset
    functionality that allows deleting everything from the application's database.
</p>
<pre>class Service {
  void deleteEverything() {
    // delete everything ...
  }
}</pre>
<p>
    Such a reset should of course only be performed by administrators and never by a normal user of our
    application. By analyzing our source code, we can make sure that this will never happen. However,
    we can expect our application to grow and to be changed in the future. Therefore, we want to implement
    a tighter security model where the method invocation is guarded by an explicit check for the application's
    current user. We will normally use a security framework for making sure that the method is never called by
    anybody but by an administrator.
</p>

<p>
    For this purpose, assume that we are using a security framework with a public API as follows:
</p>
<pre>@interface Secured {
  String user();
}

class UserHolder {
  static String user;
}

interface Framework {
  &lt;T&gt; T secure(Class&lt;T&gt; type);
}</pre>
<p>
    In this framework, the <code>Secured</code> annotation should be used to mark methods that can only be
    accessed by a given user. The <code>UserHolder</code> is used for globally defining which user is
    currently logged into the application. The <code>Framework</code> interface allows for the creation of
    secured instances by calling the default constructor of a given type. Of course, this framework is overly
    simple, but in principal this is how security frameworks like for example the popular
    <a href="http://projects.spring.io/spring-security/">Spring Security</a> work. A feature of this
    security framework is that we preserve the user's types. By the contract of our framework interface, we
    promise the user to return an instance of any type <code>T</code> it receives. Thanks to this functionality,
    a user is able to interact with his own types as if the security framework did not exist. In a test
    environment, a user could even create unsecured instances of his types and use these instances instead of the
    secured ones. You will agree that this is really handy! Such frameworks are known as being working with
    POJOs, plain old Java objects, a term that was coined for describing such non-intrusive frameworks that do
    not impose their own types upon their users.
</p>

<p>
    Imagine for now that we knew that the type handed to the <code>Framework</code> could only be <code>T =
    Service</code> and that the <code>deleteEverything</code> method was annotated with
    <code>@Secured("ADMIN")</code>. This way, we could easily implement a secured version of this particular type by
    simply subclassing it:
</p>
<pre>class SecuredService extends Service {
  @Override void deleteEverything() {
    if(UserHolder.user.equals("ADMIN")) {
      super.deleteEverything();
    } else {
      throw new IllegalStateException("Not authorized");
    }
  }
}</pre>
<p>
    With this additional class we could implement the framework as follows:
</p>
<pre>class HardcodedFrameworkImpl implements Framework {
  @Override
  public &lt;T&gt; T secure(Class&lt;T&gt; type) {
    if(type == Service.class) {
      return (T) new SecuredService();
    } else {
      throw new IllegalArgumentException("Unknown: " + type);
    }
  }
}</pre>
<p>
    Of course, this implementation is not of much use. By the <code>secure</code> method's signature we suggested
    that the method can provide security for any type but in reality, we will throw an exception once we encounter
    something else then the known <code>Service</code>. Also, this would require our security library to know
    about about this particular <code>Service</code> type when the library is compiled. Obviously, this is not a
    feasible solution for implementing the framework. So how can we solve this problem? Well, since this is a
    tutorial on a code generation library you will have guessed the answer: We create a subclass on demand
    and at runtime when the <code>Service</code> class first becomes known to our security framework by the
    invocation of the <code>secure</code> method. With code generation, we can take a given type, subclass it at
    runtime and override the methods we want to secure. In our case, we override all methods that are annotated
    with <code>@Secured</code> and read the required user from the annotation's <code>user</code> property. Many
    popular Java frameworks are implemented this way.
</p>

<h4>General information</h4>

<p>
    Before we learn all about code generation and Byte Buddy, note that you should use code generation with
    care. Java types are something rather special to the JVM and are rarely garbage collected. Therefore, you
    should never overuse code generation but only solve problems using generated code when it is the only way
    out. However, if you need to interact with unknown types while preserving this unknown type hierarchy, code
    generation is most likely your only option. Most frameworks for dependency injection, object-relational mapping
    or mocking are for example implemented this way.
</p>

<p>
    Of course, Byte Buddy is not the first library for code generation on the JVM. However, we believe that Byte Buddy
    knows some tricks the other frameworks cannot apply. The overall objective of Byte Buddy is to work declaratively,
    both by focusing on using a domain specific language and annotations. No other code generation library for the JVM
    we know of works this way. Nevertheless, you might want to have a look at some other frameworks for code generation
    to find out which one suites you best:
</p>

<dl class="dl-horizontal padded">
    <dt>
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html">Java proxies</a>
    </dt>
    <dd>
        The Java Class Library comes with a proxy toolkit that allows for the creation of classes that implement a given
        set of interfaces. This built-in proxy supplier is handy but also very limited. The above mentioned security
        framework could for example not be implemented this way since we want to extend classes and not interfaces.
    </dd>
    <dt>
        <a href="http://cglib.sourceforge.net/">cglib</a>
    </dt>
    <dd>
        The code generation library was implemented during the early years of Java and it did unfortunately not keep up
        with the development of the Java platform. Nevertheless, cglib remains a quite powerful library but its active
        development became rather vague. For this reason, many of its users moved away from cglib.
    </dd>
    <dt>
        <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/">javassist</a>
    </dt>
    <dd>
        This library comes with a compiler that takes strings containing Java source code which are translated into Java
        byte code during the runtime of an application. This is very ambitious and in principle a great idea since Java
        source code is obviously a great way for describing Java classes. However, the javassist compiler does not
        compare to the javac compiler in its functionality and allows for easy mistakes when dynamically composing
        strings to implement more complex logic. Additionally, javassist comes with a proxy library which is similar to
        the JCL's proxy utilities but allows extending classes and is not limited to interfaces. The scope of
        javassist's proxy tools remain however equally limited in its API and functionality.
    </dd>
    <dt>
        <a href="http://jodd.org/doc/proxetta/">Proxetta</a>
    </dt>
    <dd>
        Proxetta is a module of the Jodd framework and a rather young player in the code generation game. Proxetta
        focuses on the creation of proxies and can be considered similar to cglib in its approach but brings some
        advanced functionality to the plate such as using marker types for creating custom byte code.
    </dd>
</dl>

<p>
    Evaluate the frameworks for yourself but we believe that Byte Buddy offers functionality and convenience that you
    will otherwise search in vain. Byte Buddy comes with an expressive domain specific language that allows for the
    creation of very custom runtime classes by writing plain Java code and by using strong typing for your own code.
    At the same time, Byte Buddy is very open for customization and does not restrain you to the features that come out
    of the box. If required, you can even define custom byte code for any implemented method. But even without knowing
    what byte code is or how it works, you are able to do quite a lot without digging deep into the framework. Did
    you for example have a look at the <a href="#/#helloworld"><code>Hello World!</code> example</a>? Using Byte Buddy
    is that easy.
</p>

<p>
    In the following tutorial we will gradually explain the features of Byte Buddy. We will start with its more general
    features which are most likely used by a majority of users. We will then consider increasingly advanced topics and
    give a short introduction to Java byte code and the class file format. But don't be discourage by that later
    material! You can do almost anything by using Byte Buddy's standard API and without understanding any Java internal.
    For learning about the standard API, just read on.
</p>
</div>
<div class="row" id="gettingstarted">
    <h2>Creating a class</h2>

    <p>
        Any type that is created by Byte Buddy is emitted by an instance of the <code>ByteBuddy</code> class. Simply
        create a new instance by calling <code>new ByteBuddy()</code> and you are ready to go. Hopefully, you are using
        an development environment where you get suggestions on the methods that you can call on a given object. This
        way, you can avoid to manually look up a class's API in <a href="javadoc/v0_1/index.html">Byte Buddy's
        javadoc</a> but have your IDE guide you through the process. As mentioned before, Byte Buddy offers a domain
        specific language which intends to be as human-readable as possible. Your IDE's hints will therefore point you
        into the right direction most of the time. But enough of the talking, let us create a first class at a Java
        program's runtime:
    </p>
<pre>DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .make();
</pre>
    <p>
        As it is hopefully obvious, the above code example creates a new class that extends the <code>Object</code>
        type.
        This dynamically created type would be equivalent to a Java class that only extends <code>Object</code> without
        explicitly implementing any methods, fields or constructors. You might have noted that we did not even name the
        dynamically generated type, something that is required by the Java compiler. Of course, you could have easily
        named your type explicitly:
    </p>
<pre>DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .name("example.Type")
  .make();
</pre>
    <p>
        But what happens without the explicit naming? Byte Buddy lives and breaths of
        <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">convention over configuration</a> and
        provides you with defaults that we found convenient. As for the name of a type, the default Byte Buddy
        configuration provides a <code>NamingStrategy</code> which randomly creates a class name based on a dynamic
        type's superclass name. Furthermore, the name is defined to be in the same package as the subclass such
        that package-private methods of the direct superclass are always visible to the dynamic type. If you for example
        subclassed a type named <code>example.Foo</code>, the generated name will be something like
        <code>example.Foo$$ByteBuddy$$1376491271</code> where the numeric sequence is random. An exception of this rule
        is made when subclassing types from the <code>java.lang</code> package where types such as <code>Object</code>
        live. Java's security model does not allow custom types to live is this namespace. Therefore, such type names
        are prefixed with <code>net.bytebuddy.renamed</code> by the default naming strategy.
    </p>

    <p>
        This default behavior might not be convenient for you. And thanks to the convention over configuration
        principle, you can always alter the default behavior by your needs. This is where the <code>ByteBuddy</code>
        class comes into place. By creating a <code>new ByteBuddy()</code> instance, you create a default configuration
        that you can customize by your needs. Let's try this:
    </p>
<pre>DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .withNamingStrategy(new NamingStrategy() {
    @Override public String getName(UnnamedType unnamedType) {
        return "i.heart.ByteBuddy." + unnamedType.getSuperClass().getSimpleName();
    }
  })
  .subclass(Object.class)
  .make();
</pre>
    <p>
        In the above code example, we created a new configuration that differs from the default configuration in its
        type naming strategy. The anonymous class is implemented to simply concatenate the string
        <code>i.heart.ByteBuddy</code> and the base class's simple name. When subclassing the
        <code>Object</code> type, the dynamic type is therefore named <code>i.heart.ByteBuddy.Object</code>. Be however
        careful
        when creating your own naming strategies! The Java virtual machine uses names to distinguish between types
        which is why you want to avoid naming collisions. If you need to customize the naming behavior, consider
        using Byte Buddy's built-in <code>NamingStrategy.SuffixingRandom</code> which you can customize to include
        a prefix that is more meaningful to your application than our default.
    </p>

    <h4>Domain specific language and immutability</h4>

    <p>
        After seeing Byte Buddy's domain specific language in action, we need to have a short look at the way this
        language is implemented. The one detail you need to know about the implementation is that the language is built
        around <a href="http://en.wikipedia.org/wiki/Immutable_object">immutable objects</a>. As a matter of fact,
        almost every class that lives in the Byte Buddy namespace was made immutable and in the few cases we could not
        make a class immutable, we explicitly mention it in this class's javadoc. If you implement custom
        features for Byte Buddy, we recommend you to stick with this principle.
    </p>

    <p>
        As an implication of the mentioned immutability, you must be careful when for example configuring
        <code>ByteBuddy</code> instances. You might for example make the following mistake:
    </p>
<pre>ByteBuddy byteBuddy = new ByteBuddy();
byteBuddy.withNamingStrategy(new NamingStrategy.SuffixingRandom("suffix"));
DynamicType.Unloaded&lt;?&gt; dynamicType = byteBuddy.subclass(Object.class).make();
</pre>
    <p>
        You might have expected the dynamic type to be generated using the custom naming strategy
        <code>new NamingStrategy.SuffixingRandom("suffix")</code> that was allegedly defined. Instead of mutating the
        instance that is stored in the <code>byteBuddy</code> variable, the invocation of the
        <code>withNamingStrategy</code> method returns a customized <code>ByteBuddy</code> instance which is however
        lost. As a result, the dynamic type is created using the default configuration which was originally created.
    </p>

    <h4>Loading a class</h4>

    <p>
        So far we only have defined and created a dynamic type but we did not make any use of it. A type that is
        created by Byte Buddy is represented by an instance of <code>DynamicType.Unloaded</code>. As the name
        suggests, these types are not loaded into the Java virtual machine. Instead, classes created by Byte Buddy are
        represented in their binary form, in the
        <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Java class file format</a>. This way,
        it is up to you to decide what you want to do with a generated class. For example, you might want to run
        Byte Buddy from a build script that only generates classes to enhance a Java application before it is deployed.
        For this purpose, the <code>DynamicType.Unloaded</code> class allows to extract a byte array that represents
        the dynamic type. For convenience, the type additionally offers a <code>saveIn(File)</code> method that allows
        you to store a class in a given folder.
    </p>

    <p>
        While directly accessing a class's binary form is straight forward, loading a type is unfortunately more
        complex. In Java, all classes are loaded using a <code>ClassLoader</code>. One example for such a class loader
        is the bootstrap class loader which is responsible for loading the classes of the Java Class Library. The
        system class loader, on the other hand, is responsible for loaded classes from the Java class path.
        Obviously, none of these class loaders or any other class loader is aware of a dynamic class we have created.
        To overcome this, we have to find other possibilities for loading a runtime generated class. Byte Buddy offers
        solutions to two different approaches out of the box:
    </p>

    <ul class="colored-list padded">
        <li><span>
            We simply create a new <code>ClassLoader</code> which is explicitly told about the existence of a
            particular dynamically created class. Because
            Java class loaders are organized in hierarchies, we will define this class loader as the child of a given
            class loader that already exists in the running Java application. This way, all types of the running
            Java program will be visible to the dynamic type that was loaded with new new <code>ClassLoader</code>.
        </span></li>
        <li><span>
            We can use reflection to inject a new type into an existent class loader. Usually, a class loader is asked
            to provide a given type by its name. Using reflection, we can turn this principle around and call a
            protected method to inject a new class into the class loader without the class loader actually knowing how
            to locate this dynamic class.
        </span></li>
    </ul>

    <p>
        Unfortunately, both approaches have downsides.
    </p>

    <ul class="colored-list padded">
        <li><span>
            If we create a new <code>ClassLoader</code>, this class loader defines a new namespace. As an implication,
            it is possible to load two classes with identical name as long as these classes are loaded by two different
            class loaders. These two classes will then never be considered as equal by a Java virtual machine, even if
            both classes represent an identical class implementation.
            This rule for equality hold however also for
            Java packages. This means that a class <code>example.Foo</code> will not be able to access package-private methods
            of another class <code>example.Bar</code> if both classes were not loaded with the same class loader.
        </span></li>
        <li><span>
            Whenever a class is loaded, the class's class loader will look up any class that is referenced in this class
            once a code segment referencing a class is is resolved. This lookup delegates to the same class loader. Imagine
            a scenario where we dynamically created two classes <code>example.Foo</code> and <code>example.Bar</code>.
            If we injected <code>example.Foo</code> into an existent class loader, this class loader might attempt to
            locate <code>example.Bar</code>. This lookup will however fail since the latter class was created dynamically
            and is unreachable for the class loader into which we just injected the <code>example.Foo</code> class.
            Therefore, the reflective approach cannot be used for classes with circular dependencies that become
            effective during class loading.
        </span></li>
    </ul>

    <p>
        You might consider the chance of encountering circular dependencies to be of minor relevance since you
        are creating one dynamic type at a time. However, the dynamic creation of a type might trigger the creation of
        so-called auxiliary types. These types are created by Byte Buddy automatically to provide access to the dynamic
        type you are creating. We will learn more about auxiliary types in the following section, do not worry about
        them for now. However, because of this, we recommend you to load dynamically created classes by creating a
        specific <code>ClassLoader</code> instead of injecting them into an existing one, whenever possible.
    </p>

    <p>
        After creating a <code>DynamicType.Unloaded</code>, this type can be loaded using a
        <code>ClassLoadingStrategy</code>. Byte Buddy provides two such strategies out of the box where each follows
        one of the concepts that were described above. These strategies are defined in <code>ClassLoadingStrategy.Default</code> where
        the <code>WRAPPER</code> strategy will create a new <code>ClassLoader</code> and the <code>INJECTION</code>
        strategy will attempt to inject a dynamic type using reflection. Let's look at such class loading in action:
    </p>
<pre>Class&lt;?&gt; new ByteBuddy()
  .subclass(Object.class)
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded();
</pre>
    <p>
        In the above example, we have created and loaded a class. We used the <code>WRAPPER</code> strategy for loading
        the class which is suitable for most cases, as mentioned above. However, for this easy class creation, the
        <code>INJECTION</code> strategy would have worked as well. Finally, the <code>getLoaded</code> method returns an instance
        of a Java <code>Class</code> that represents the dynamic class.
    </p>
</div>
<div class="row" id="members">
    <h2>Fields and methods</h2>

    <p>
        To be completed.
    </p>
</div>
<div class="row" id="attributes">
    <h2>Attributes and annotations</h2>

    <p>
        To be completed.
    </p>
</div>
<div class="row" id="cookbook">
    <h2>Cook book</h2>

    <p>
        To be completed.
    </p>
</div>
<div class="row" id="customization">
    <h2>Custom methods</h2>

    <p>
        To be completed.
    </p>
</div>
</div>
</div>
