<div class="row">
<div class="col-xs-6 col-md-3" style="height: 100%;">
    <div class="sidebar hidden-print affix-top" role="complementary" data-affix="0">
        <div style="padding: 40px 0 0 15px;">
            <ul class="nav nav-tabs nav-stacked" style="border: 0;">
                <li><a href="#concept" data-du-smooth-scroll="" data-du-scrollspy="" data-offset="40">What for?</a>
                </li>
            </ul>
        </div>
    </div>
</div>
<div class="col-md-8 col-md-offset-1" id="affixComponent">
<div class="row" style="background-color: orange; font-weight: bold; color: #ffffff; padding: 5px;">
    This tutorial is currently in the make. We hope to publish a first release of Byte
    Buddy together with the completed version of this webpage before July 2014!
</div>
<div class="row" id="concept">
<h2>Why runtime code generation?</h2>

<p>
    The Java language comes with a comparatively strict type system. Java requires all variables and objects
    to be of a specific type and an attempt to assign incompatible types will always cause an error. These
    errors will usually be emitted by the Java compiler or at the very least by the Java runtime, if a
    developer has made erroneous use of explicit type castings. This behavior is great for writing business
    applications because business domains can usually be described in such an explicit manner. This way, we can
    use Java to build very readable and robust applications. Among other things, it is Java's type system
    that is responsible for Java's popularity in enterprise programming.
</p>

<p>
    However, by enforcing its strict type system, Java imposes limitations that restrict the language's
    scope of use in other domains. For example, when writing a library that is to be used by other Java
    applications, we will normally not be able to use any type that is defined in the user's application
    because these types are unknown to us when our library is compiled. In order to call methods or access
    fields of the user's code, the Java Class Library comes with a reflection API. Using the reflection API,
    we are able to introspect unknown types and to call methods or access fields. Unfortunately, the use of
    the reflection API has two significant downsides:
</p>
<ul>
    <li>
        Using the reflection API is
        <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">slower</a> than a hard-coded method
        invocation: First, one needs to perform a rather expensive method lookup to get hold of an object that
        describes a specific method. And when a method is invoked, this requires the JVM to run native code
        which requires long run time compared to a direct invocation. However, modern JVMs know a concept called
        <a href="https://blogs.oracle.com/buck/entry/inflation_system_properties">inflation</a> where the
        JNI-based method invocation is replaced by generated byte code that is injected into a dynamically
        created class. As you can see, even the JVM itself uses code generation!
    </li>
    <li>
        The reflection API breaks type-safety: Even though the JVM is capable of improving the reflective
        runtime, we might be required to expose this reflective API to our library's users when enhancing
        the user types. However, type-safety is one of Java's strong suites. We do not want to take it away when
        interacting with out user's code. To get a better understanding of the problem, let us look at the
        example of a miniature security library.
    </li>
</ul>
<h4>Writing a security library</h4>

<p>
    Business applications can grow large and sometimes it is difficult to keep an overview of call stacks
    in our application. This can become problematic when we have crucial methods in our application that should
    only be called in special circumstances. Imagine a business application that implements a reset
    functionality that allows deleting everything from the application's database.
</p>
<pre>class Service {
  void deleteEverything() {
    // delete everything ...
  }
}</pre>
<p>
    Such a reset should of course only be performed by administrators and never by a normal user of our
    application. By analyzing our source code, we can make sure that this will never happen. However,
    we can expect our application to grow and to be changed in the future. Therefore, we want to implement
    a tighter security model where the method invocation is guarded by an explicit check for the application's
    current user. We will normally use a security framework for making sure that the method is never called by
    anybody but by an administrator.
</p>

<p>
    For this purpose, assume that we are using a security framework with a public API as follows:
</p>
<pre>@interface Secured {
  String user();
}

class UserHolder {
  static String user;
}

interface Framework {
  &lt;T&gt; T secure(Class&lt;T&gt; type);
}</pre>
<p>
    In this framework, the <code>Secured</code> annotation should be used to mark methods that can only be
    accessed by a given user. The <code>UserHolder</code> is used for globally defining which user is
    currently logged into the application. The <code>Framework</code> interface allows for the creation of
    secured instances by calling the default constructor of a given type. Of course, this framework is overly
    simple, but in principal this is how security frameworks like for example the popular
    <a href="http://projects.spring.io/spring-security/">Spring Security</a> work. A feature of this
    security framework is that we preserve the user's types. By the contract of our framework interface, we
    promise the user to return an instance of any type <code>T</code> it receives. Thanks to this functionality,
    a user is able to interact with his own types as if the security framework did not exist. In a test
    environment, a user could even create unsecured instances of his types and use these instances instead of the
    secured ones. You will agree that this is really handy! Such frameworks are known as being working with
    POJOs, plain old Java objects, a term that was coined for describing such non-intrusive frameworks that do
    not impose their own types upon their users.
</p>

<p>
    Imagine for now that we knew that the type handed to the <code>Framework</code> could only be <code>T =
    Service</code> and that the <code>deleteEverything</code> method was annotated with
    <code>@Secured("ADMIN")</code>. This way, we could easily implement a secured version of this particular type by
    simply subclassing it:
</p>
<pre>class SecuredService extends Service {
  @Override void deleteEverything() {
    if(UserHolder.user.equals("ADMIN")) {
      super.deleteEverything();
    } else {
      throw new IllegalStateException("Not authorized");
    }
  }
}</pre>
<p>
    With this additional class we could implement the framework as follows:
</p>
<pre>class HardcodedFrameworkImpl implements Framework {
  @Override
  public &lt;T&gt; T secure(Class&lt;T&gt; type) {
    if(type == Service.class) {
      return (T) new SecuredService();
    } else {
      throw new IllegalArgumentException("Unknown: " + type);
    }
  }
}</pre>
<p>
    Of course, this implementation is not of much use. By the <code>secure</code> method's signature we suggested
    that the method can provide security for any type but in reality, we will throw an exception once we encounter
    something else then the known <code>Service</code>. Also, this would require our security library to know
    about about this particular <code>Service</code> type when the library is compiled. Obviously, this is not a
    feasible solution for implementing the framework. So how can we solve this problem? Well, since this is a
    tutorial on a code generation library you will have guessed the answer: We will create a subclass on demand
    and at runtime when the <code>Service</code> class first becomes known to our security framework by the
    invocation of the <code>secure</code> method. With code generation, we can take a given type, subclass it at
    runtime and override the methods we want to secure. In our case, we will override all methods that are annotated
    with <code>@Secured</code> and read the required user from the annotation's <code>user</code> property. Many
    popular Java frameworks are implemented this way.
</p>

<h4>General information</h4>

<p>
    Before we learn all about code generation and Byte Buddy, note that you should use code generation with
    care. Java types are something rather special to the JVM and are rarely garbage collected. Therefore, you
    should never overuse code generation but only solve problems using generated code when it is the only way
    out. However, if you need to interact with unknown types while preserving this unknown type hierarchy, code
    generation is most likely your only option. Most frameworks for dependency injection, object-relational mapping
    or
    mocking are for example implemented this way.
</p>

<p>
    Of course, Byte Buddy is not the first library for code generation on the JVM. However, we believe that Byte Buddy
    knows some tricks the other frameworks cannot apply. The overall objective of Byte Buddy is to work declaratively,
    both by focusing on using a domain specific language and annotations. No other code generation library for the JVM
    we know of works this way. Nevertheless, you might want to have a look at some other frameworks for code generation
    to find out which one suites you best:
</p>
<ul>
    <li>
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html">Java proxies</a>:
        The Java Class Library comes with a proxy toolkit that allows for the creation of classes that
        implement a given set of interfaces. This built-in proxy supplier is handy but also very limited.
        The above mentioned security framework could for example not be implemented this way since we
        want to extend classes and not interfaces.
    </li>
    <li>
        <a href="http://cglib.sourceforge.net/">cglib</a>: The code generation library was implemented
        during the early years of Java and it did unfortunately not keep up with the development of the
        Java platform. Nevertheless, cglib remains a quite powerful library but its active development
        became rather vague. For this reason, many of its users moved away from cglib.
    </li>
    <li>
        <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/">javassist</a>: This library comes with
        a compiler that takes strings containing Java source code which are translated into Java byte code during
        the
        runtime of an application. This is very ambitious and in principle a great idea since Java source
        code is obviously a great way for describing Java classes. However, the javassist
        compiler does not compare to the javac compiler in its functionality and allows for easy mistakes
        when dynamically composing strings to implement more complex logic. Additionally, javassist comes
        with a proxy library which is similar to the JCL's proxy utilities but allows extending classes and
        is not limited to interfaces. The scope of javassist's proxy tools remain however equally limited in its API
        and functionality.
    </li>
    <li>
        <a href="http://jodd.org/doc/proxetta/">Proxetta</a>: Proxetta is a module of the Jodd framework and a
        rather young player in the code generation game. Proxetta focuses on the creation of proxies and can be
        considered similar to cglib in its approach but brings some advanced functionality to the plate such as using
        marker types for creating custom byte code.
    </li>
</ul>
<p>
    See for yourself but we believe that Byte Buddy offers functionality that is not offered by any of these libraries.
    Byte Buddy comes with an expressive domain specific language that allows for the creation of very custom runtime
    classes by writing plain Java code and by using strong types. At the same time, Byte Buddy is very open for
    customization and will not restrain you to the features that come out of the box. If required, you can even define
    custom byte code for any implemented method. But even without knowing what byte code is or how it works, you will be
    able to do quite a lot without digging deep into the framework. Did you for example have a look at the
    <a href="#/#helloworld"><code>Hello World!</code> example</a>? Using Byte Buddy is that easy.
</p>

<p>
    In the following tutorial we will gradually explain the features of Byte Buddy. We will start with its more general
    features which are most likely used by a majority of users. We will then consider increasingly advanced topics and
    give a short introduction to Java byte code and the class file format. But don't be discourage by that! You can
    do almost anything by using Byte Buddy's standard API and without understanding any Java internal. For learning
    about the standard API, just read on.
</p>
</div>
</div>
</div>
